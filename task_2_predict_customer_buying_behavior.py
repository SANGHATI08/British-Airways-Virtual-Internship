# -*- coding: utf-8 -*-
"""Task 2 - predict customer buying behavior.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1w1Y5D5-c435pjoKr0-Q6bjW_7hXP3NJA

# **Task 2
**Predictive modeling of customer bookings**

This colab file includes some code to get started with this predictive modeling task.

*Importing the csv file*
"""

import pandas as pd
df = pd.read_csv('/content/customer_booking.csv', encoding='latin1')
df.head()

df.isnull().sum()

df.info()

"""There are 13 different variables (excluding the target). Among these independent variables, 8 are numerical type and 5 are object type."""

df.describe()

df["flight_day"].unique()

import matplotlib.pyplot as plt
import seaborn as sns

dayperday = df.groupby('flight_day')['num_passengers'].mean().reset_index()
ax = ax = sns.barplot(data = dayperday, x= 'flight_day', y= 'num_passengers')

plt.show()

"""the average number of passengers, weekends have a higher value than weekdays, so need see the number of flights from day to day"""

df['flight_day'].value_counts().reset_index().sort_values(by='index')

"""From the table above,its seen that weekends have fewer flights than weekdays, so need to see what routes have schedules on weekends with the most passengers."""

df['route'].value_counts()

df['booking_origin'].value_counts()

booking_values = df['booking_complete'].value_counts()
booking_labels = ['Not Completed', 'Completed']
sns.barplot(x = booking_labels, y = booking_values, palette = "Blues").set(title='Booking completion')

"""It seems that there is a class imbalance in target variable. This might later compromise the performance of some models, which means it is need to fix this imbalance using resampling methods. However, the class imbalance is not extreme,so can try some models without undersampling the majority class / oversampling the minority class

"""

import seaborn as sns
sns.countplot(data = df, x = 'num_passengers', hue = 'booking_complete', palette = 'Blues').set(title ='Distribution of number of passengers' )

df['sales_channel'].value_counts()

sns.countplot(data = df, x = 'sales_channel', hue = 'booking_complete', palette = 'Blues').set(title ='Sales channel and booking completion' )

df['trip_type'].value_counts()

sns.countplot(data = df, x = 'trip_type', hue = 'booking_complete', palette = 'Blues').set(title ='Trip type and booking completion' )

sns.boxplot(data = df, x = 'length_of_stay', color = 'lightblue').set(title= 'Distribution of length of stay')

sns.countplot(data = df, x = 'flight_hour', hue = 'booking_complete', palette = 'Blues').set(title = 'Distribution of flight hours filtered by booking completion')

sns.countplot(data = df, x = 'flight_day', hue = 'booking_complete', palette = 'Blues').set(title = 'Distribution of flight days, filtered by booking completion')

df['route'].value_counts()

"""There are 799 different routes. so transform this column into the distances between the two airports of the route."""

palette = sns.color_palette("Blues", n_colors = 10)
palette.reverse()

largest_origins = df['booking_origin'].value_counts().nlargest(10)
df_largest_origins = pd.DataFrame(largest_origins)
plt.figure(figsize=(11,5))
sns.barplot(data = df_largest_origins, x = df_largest_origins.index , y = 'booking_origin', palette = palette).set(title = 'Most common booking origins')
plt.show()

palette = sns.color_palette("Blues", n_colors = 10)
palette.reverse()

aux = df.loc[df['booking_complete'] == 1]
largest_origins = aux['booking_origin'].value_counts().nlargest(10)
df_largest_origins = pd.DataFrame(largest_origins)
plt.figure(figsize=(11,5))
sns.barplot(data = df_largest_origins, x = df_largest_origins.index , y = 'booking_origin', palette = palette).set(title = 'Most common completed booking origins')
plt.show()

df['wants_extra_baggage'].value_counts()

sns.countplot(data = df, x = 'wants_extra_baggage', hue = 'booking_complete', palette = 'Blues').set(title = 'Wants extra baggage,filtered by booking completion')

df['wants_preferred_seat'].value_counts()

sns.countplot(data = df, x = 'wants_preferred_seat', hue = 'booking_complete', palette = 'Blues').set(title = 'Wants preferred seat, filtered by booking completion')

df['wants_in_flight_meals'].value_counts()

sns.countplot(data = df, x = 'wants_in_flight_meals', hue = 'booking_complete', palette = 'Blues').set(title = 'Wants in flight meals, filtered by booking completion')

sns.histplot(data = df, x = 'flight_duration', color = 'lightblue').set(title = 'Distribution of flight duration')

num = ['num_passengers', 'purchase_lead', 'length_of_stay', 'flight_hour', 'flight_duration']

plt.figure(figsize=(12,8))

for i, column in enumerate (df[num].columns, 1):
    plt.subplot(4,4,i)
    sns.kdeplot(data=df[num], x=df[column])
    plt.tight_layout()

"""*as flight days are obj type variable we cant make model with this so we need to transform the days into float *


**process 1** - by mapping


mapping = { "Mon": 1, "Tue": 2, "Wed": 3, "Thu": 4, "Fri": 5, "Sat": 6, "Sun": 7, }

df["flight_day"] = df["flight_day"].map(mapping)

**process 2-**
"""

df = df.replace({'flight_day': {'Mon' : 0, 'Tue' : 1, 'Wed' : 2, 'Thu' : 3, 'Fri' : 4, 'Sat' : 5, 'Sun' : 6}})
df['flight_day'].unique()

"""drop categorical columns now"""

df.drop(['route', 'sales_channel', 'trip_type','booking_origin'], axis=1, inplace = True)

"""# **Data Cleaning**
store the label for supervised learning
"""

label = df['booking_complete']

df_final = df.drop('booking_complete', axis=1)

df_final.head()

"""heatmap"""

corr = df_final.corr()

plt.figure(figsize=(10,7))

#plot the heatmap
sns.heatmap(corr)

"""# **Split Data**"""

from sklearn.model_selection import train_test_split

X = df_final
Y = label

X_train, X_test, Y_train, Y_test = train_test_split(X, Y, test_size= 0.2, stratify=Y, random_state=2)

"""# **build the classification algo**
# *XGBClassifier*
"""

import xgboost as xgb

clf = xgb.XGBClassifier()
clf.fit(X_train, Y_train)

#accuracy score
from sklearn.metrics import accuracy_score
X_test_prediction = clf.predict(X_test)
data_accuracy = accuracy_score(X_test_prediction, Y_test)
print('accuracy score:' , data_accuracy)

"""# *Decision Tree classifier*"""

from sklearn.tree import DecisionTreeClassifier
decisiontree = DecisionTreeClassifier()
decisiontree = decisiontree.fit(X_train,Y_train)

#accuracy score
X_test_prediction = decisiontree.predict(X_test)
data_accuracy = accuracy_score(X_test_prediction, Y_test)
print('accuracy score:' , data_accuracy)

"""# *Random Forest*"""

from sklearn.ensemble import RandomForestClassifier
clf_rf= RandomForestClassifier()
clf_rf.fit(X_train, Y_train)

#accuracy score
X_test_prediction = clf_rf.predict(X_test)
data_accuracy = accuracy_score(X_test_prediction, Y_test)
print('accuracy score:' , data_accuracy)

"""# *Confusion Matrix of the test set(RandomForestClassifier)*"""

from yellowbrick.classifier import ConfusionMatrix
cm = ConfusionMatrix(clf_rf, classes=[0,1])
cm.fit(X_train, Y_train)

cm.score(X_test, Y_test)

"""# *Random Forest Feature Importance*"""

import numpy as np

importances = clf_rf.feature_importances_

# Sort the feature importance in descending order

sorted_indices = np.argsort(importances)[::-1]

feat_labels = df.columns[1:]

for f in range(X_train.shape[1]):
    print("%2d) %-*s %f" % (f + 1, 30,
                            feat_labels[sorted_indices[f]],
                            importances[sorted_indices[f]]))

import matplotlib.pyplot as plt

plt.title('Feature Importance')
plt.bar(range(X_train.shape[1]), importances[sorted_indices], align='center')
plt.xticks(range(X_train.shape[1]), X_train.columns[sorted_indices], rotation=90)
plt.tight_layout()
plt.show()

"""
# *LogisticRegression*"""

from sklearn import linear_model
logr = linear_model.LogisticRegression()
logr.fit(X_train,Y_train)

#accuracy score
from sklearn.metrics import accuracy_score
X_test_prediction = logr.predict(X_test)
data_accuracy = accuracy_score(X_test_prediction, Y_test)
print('accuracy score:' , data_accuracy)

"""as in the logistic regression model the accuracy score is high


# *Confusion Matrix of the test set*(logistic regression)
"""

from yellowbrick.classifier import ConfusionMatrix
cm = ConfusionMatrix(logr, classes=[0,1])
cm.fit(X_train, Y_train)

cm.score(X_test, Y_test)

"""#Feature Importance In Logistic Regression#"""

import numpy as np
coefficients = logr.coef_[0]

feature_importance = pd.DataFrame({'Feature': X.columns, 'Importance': np.abs(coefficients)})
feature_importance = feature_importance.sort_values('Importance', ascending=True)
feature_importance.plot(x='Feature', y='Importance', kind='barh', figsize=(10, 6))